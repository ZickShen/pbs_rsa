# pbs_rsa

A partially blind signature implementation based on RSA in pure Rust, which is a raw implementation of [Partially Blind Threshold Signature Based on RSA](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.112.4225&rep=rep1&type=pdf)

:warning: **WARNING:** This library has __not__ been audited, so please do not use for production code.

## Usage

`Cargo.toml`:

```
[dependencies]
pbs_rsa = { git = "https://github.com/ZickShen/pbs_rsa" }
```

`main.rs`:

```

extern crate rand;
extern crate pbs_rsa;
extern crate num_bigint_dig as num_bigint;
use num_bigint::BigUint;
use std::str::FromStr;
use pbs_rsa::{PrivateKey, PublicKey, Signature};

fn main(){

  let mut rng = rand::thread_rng();
  let bits: usize = 2048;
  let sk = PrivateKey::new(&mut rng, bits).unwrap();

  let pk = PublicKey::from(sk);

  let msg = b"Real news";
  
  let (beta_invert, t) = sk.sign(
      "common message".to_string(),
      BigUint::from_str("3901299069153363958344330320245598303021500586753787320771731775495059956717332029019162090693929340327005241354267368196020351734183420216444083367055750126081350512361530442922450504485698719979749675864850997705708794663012728587597919939511366645150072691766077993787269004315054515240604192832582400684122999657724120694049766920310185086388844169849254530441494262288412461654196883486143916209704623875347971785695825567520540217429842406957890905775212215715828871451878135530548639083784982049408382335564750198687626285729999781411843488193676055759654408650673762066179185498209444056769616774794795841304").unwrap(),
      BigUint::from_str("8211154237262957750824851398649095727045018803402529353187527603005290757573654932004701585362181347952480873725915652872750202928387856062729728261531329791837548501557463375448077650624584424530785306286515944850179203110861077726625285942861036980364696517911090106034122821584168249434437139716863949609694773805313428499115269316992155377942213701365743483079356569984376295260330283680361443490966922216007971501891116976591819165328308484009578737525182275450690307196713071330582089521781699069280258535671743727125362043227763208985308537752600848446969277453254461416415659469630008973951532595934822447162").unwrap(),
      BigUint::from_str("14760395973925000324994643308218898334154912925660457879054681888068656443613089025583724296719402529682905746522039690764839299993908031755649840928728763008660809072616773291215536243890045109542798607083708210884608930475056882300685313079655831097309590370730963405980806681137934242500637882044226055135617833822168714094315209540754543414896434199774005501832393960875023764818950242672530222966609822365768960353128674211049325564004944977158530231453745458663292832741099325952319445382927367130311533249827895582906922607463196545988198198451286156813076442616545410920252680325024493552112412709107394443586").unwrap()
  );

  // derive signature from t, should be done at client otherwise
  // server have information to identify who apply for signature

  let want_sig = Signature{
    a: "test_case".to_string(),
    c: BigUint::from_str("10916493395836605395940068713220040225479877628469359860815830724454244960145138341291125639672178075737060865426968441801349448209307493915432881909058335477963144782683945050947332300891139333064803210092878927246243287223787755915062338476347479644347780647597843345265207196565395330309866188679899054643041314783738435672853369585742435321106501831930213765695074834526120568061783224803038245947255804046015554935549436673455209368734263078195183856452081136578469384150910237377173174799939300985003481762852129492195365825738536333367358955369756090804965727493117758037646966969799799484888828106318796094777").unwrap(),
    s: BigUint::from_str("7295011630424823998555001642254372585459278059409240672771972721639035959179826459530740688073129189700694158715168375369751197617237993628366667003973542155488808814022079414288108004550507960345729317118308104707000933461491689430218887299542186686977977129415530259000262285702450544881144654051955930885572061614549449301008237943865032925091100859744915386794889287739372049516661307481029746985065319365402334092938879275912784344709948463175840750268915920986124529630494095801143081502157294414414210882570908132282807231374147615342279055416709920976255341226219224574473132218899290657824723098939379451001").unwrap()
  };
  assert!(pk.verify("test_case".to_string(), &want_sig).is_ok())
}
```

## Testing

Run tests with:

```
$ cargo test
```

## Benchmark

Benchmarking functionality is kept in the [`benches` directory](benches). You
can run the benchmarks with the following command:

```
$ RUSTFLAGS="-C target_cpu=native" cargo bench
```

We use the [`becher`](https://crates.io/crates/bencher) benchmarking library.
